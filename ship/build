#! /bin/sh
set -euf

## SYNOPSIS
# [debug=true] build compile SRCFILE DSTFILE
# [debug=true] build deps SRCFILE...
build() {
  case "$1" in
    compile) build_compile "$2" "$3";;
    deps) shift; build_deps "$@";;
    *) echo "build: $1: bad command" >&2; return 23;;
  esac
}

## usage: #@include \([0-9A-Za-z]\+\) -> build_include \1 \2
build_include() { cat<<EOF
$1a\\
# begin $2
$1r$(build_resolve $2)
$1a\\
# end $2
EOF
}

## usage: #@info -> build_info \1
build_info() { cat<<EOF
$1a\\
# this file was generated by //ship/build\\
#   date: $(date -u --rfc-3339=s)\\
#   version: $(git rev-parse HEAD)
EOF
}

## usage: build_compile SRCFILE DSTFILE
build_compile() {
  setf build_directives '$(make_build_directives "$%s")' 0
  setf build_x_directive_loader '$(make_build_x_directive_loader "$%s")' 0

  eval "$build_x_directive_loader"

  setf input_parser '$(make_input_parser "$%s")' 0
  setf sentinel '$(make_needs_compilation_sentinel $%s)' build_directives

  SRCFILE="$1" setf src '$(cat "$%s")' SRCFILE

  while needs_compilation "$src" "$sentinel"; do
    setf sedgen '$(echo "$%s" | nl -b a -s \  | sed "$%s")' src input_parser
    setf sedscript '$(eval "$%s")' sedgen
    setf src '$(echo "$%s" | sed -n "$%s")' src sedscript
  done

  echo "$src" > "$2"
  chmod +x "$2"
}

## usage: needs_compilation SHELLSCRIPT SENTINEL
# Returns true if SRCFILE contains compilation directives.
needs_compilation() {
  echo "$1" | grep -q "$2"
}

## usage: build_deps SRCFILE...
# Print all the dependencies of SRCFILE... (in alphabetic order) to stdout.
build_deps() {
  while test $# -gt 0; do
    deps="$(
      for f; do
        for d in $(sed -n 's:^'"$build_include_directive"'$:\1:p' "$f"); do
          build_resolve $d
        done
      done
    )"
    set -- $deps
    if test $# -gt 0; then
      echo "$deps"
    fi
  done | sort | uniq
}

## usage: build_resolve LIBNAME
build_resolve() {
  echo "$BUILD_PATH" | tr : \\n |
    xargs -I: printf '%s/%s\n' : "$1" |
    xargs -I: ls -d : 2>/dev/null |
    head -n 1 |
    grep . ||
  {
    echo "build resolve: $1: library not found" >&2
    return 23
  }
}

## usage: make_input_parser FILENAME
make_input_parser() {
  echo "$(sed -n '
    s/^## usage: \(.*\) -> \([^ ]\+\) \(.*\)$/s:^ *\\([0-9]\\+\\) \1$:\2 \3:/p
    $a\
t;s:^ *\\([0-9]\\+\\) .*:echo \\1p:
  ' "$1")"
}

## usage: make_build_directives FILENAME
make_build_directives() {
  echo "$(sed -n '
    s/^## usage: \(.*\) -> \([^ ]\+\) \(.*\)$/\2_directive/p
  ' "$0")"
}

## usage: make_build_x_directive_loader FILENAME
make_build_x_directive_loader() {
  sed -n '
    s/^## usage: \(.*\) -> \([^ ]\+\) \(.*\)$/\2_directive='"'"'\1'"'"'/p
  ' "$1"
}

## usage: make_needs_compilation_sentinel BUILD_DIRECTIVES...
make_needs_compilation_sentinel() {
  echo "^\\($(
    for directive; do
      eval echo \"\$$directive\"
    done |
      tr \\n \| |
      sed 's/|/\\|/'
  )\\)$"
}

## usage: setf NAME FMT [ARG...]
setf() {
  value_script="$(shift; printf "$@")"

  eval "$1=$value_script"

  if test "${debug-false}" = true; then
    eval 'echo "[35m$1=\"$value_script\"[m"'
    eval 'echo "'"\$$1"'"' | nl -b a
  fi >&2
}

## main
build "$@"
