#! /bin/sh

noise_set() { # set a variable
  case "$1" in
    (-q|--quiet) echo=: ; shift ;;
    (*) echo=echo ;;
  esac
  case $# in
    (0) ## print all noise variables
      env | sed -rn '
        s/^noise_([[:alnum:]_]+)=(.*)$/[35;4m\1[;35m = [32m\2[m/p
      ' | sort
    ;;
    (1) ## print value the specified variable
      eval "echo \"[35;4m$1[0;35m = [0;32m\$noise_$1[m\""
    ;;
    (*) ## set the specified variable
      if echo "$1" | grep -q '[^[:alnum:]_]' ; then
        fail invalid variable name "[4m$1"
        return 23
      fi
      eval "old=\"\$noise_$1\""
      if test "x$old" = "x$2" ; then
        eval "$echo \"[35;4m$1[0;35m is already [0;32m$2[m\""
      elif test -z "$old" ; then
        eval "export noise_$1='$2' ; $echo \
\"[35;4m$1[0;35m set to [0;32m$2[m\""
      else
        eval "export noise_$1='$2' ; $echo \
\"[35;4m$1[0;35m changed from $old to [0;32m$2[m\""
      fi
      ## write variable to $env
      if grep -q "^$1=" "$env" ; then
        sed -ri "s'^($1)=(.*)\$'\1=\'$2\''" $env
      else
        echo "$1='$2'" >>$env
      fi
    ;;
  esac
}

noise_quit() { # exit
  echo "[35mGood bye![m"
  exit
}

fail() {
  echo "[31mFAIL: $*[m"
  return 23
}

cleanup() {
  rm -f $linefeed $env
  kill $jobs
}


qname="`readlink -f "$0"`"
dirname="`dirname "$qname"`"
export HOME='/home/shack'
if test -d "$dirname/modules" ; then
  export NOISE_PATH="${NOISE_PATH+$NOISE_PATH:}$dirname/modules"
  export NOISE_PATH="${NOISE_PATH+$NOISE_PATH:}$HOME/noise/modules"
fi
linefeed="/tmp/noise-client-$$"
env="/tmp/noise-client-$$-env"
trap cleanup EXIT
mkfifo $linefeed
touch $env
##
##
##
readline() {
  { read && echo "$REPLY" ; } | sed -rn "
    s/[']//g
    s/~%/\n/g
    s:^/([a-z]+)([[:space:]]+(.*))?$:command=\1; args='\3';:p;t
    s@^([[:alnum:]_/+-]+):[[:space:]]*(.*)@command=lang; args='\1 \2';@p;t
    s@^\![[:space:]]*(.*)@command=play; args='\1';@p;t
    s:.*:command='$noise_default_command'; args='&';:p;t
  "
}
##
##
##
while echo -n "$noise_prompt" && eval "`readline`" ; do
  ## modcall
  for dir in `echo "$NOISE_PATH" | tr : \ ` ; do
    module="$dir/$command"
    if test -x "$module" ; then
      shift
      eval 'NOISE="$0" NOISE_linefeed="$linefeed" "$module"' "$args"
      continue 2
    fi
  done
  ## funcall
  if type noise_$command &>/dev/null ; then
    eval 'noise_$command' "$args"
    continue
  fi
  ##
  fail unknown command "[4m$command[m"
done <$linefeed &
jobs="${jobs+$jobs }`jobs -p`"
##
##
##
cat<<EOF
[35mwelcome to [4mSHACK UTTERANCE[;35m version 0.9 beta 3
get help with [32m/help[m
[33mTIP: benutze [4mrlwrap[;33m fÃ¼r eine elitÃ¤re Kommandozeile.[m
EOF
##
##
##
exec >>$linefeed
##
##
##
echo '/set prompt "[30mREADY.[m~%"'
echo '/set default_command espeak'
##
##
##
while read ; do
  case $REPLY in
    (/quit) echo /quit ; exit ;; 
    (*) tr \; \\n | grep . ;;
  esac<<EOF
$REPLY
EOF
done
#### end of file.
